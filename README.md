# Практическая работа: Алгоритмы сортировки и поиска

Данный документ содержит описание и анализ алгоритмов сортировки и поиска, реализованных на языке **Python**.  
Каждый алгоритм сопровождается объяснением принципа работы, оценкой сложности (временной и пространственной), а также примерами входных и выходных данных.

---

## 1. Алгоритмы сортировки

### 1.1 Сортировка выбором (Selection Sort)

**Сложность:**  
- Временная: O(n²)  
- Пространственная: O(1)

**Описание:**  
Алгоритм проходит по массиву, находит минимальный элемент и меняет его местами с текущим.  
Процесс повторяется для всех позиций массива.

**Пример:**
```python
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print(arr)  # [11, 12, 22, 25, 64]
```

---

### 1.2 Сортировка пузырьком (Bubble Sort)

**Сложность:**  
- Временная: O(n²)  
- Пространственная: O(1)

**Описание:**  
Сравниваются соседние элементы массива и при необходимости меняются местами.  
На каждом проходе «всплывает» наибольший элемент.

**Пример:**
```python
arr = [5, 3, 8, 4, 2]
bubble_sort(arr)
print(arr)  # [2, 3, 4, 5, 8]
```

---

### 1.3 Сортировка вставками (Insertion Sort)

**Сложность:**  
- Временная: O(n²) в худшем случае, O(n) в лучшем  
- Пространственная: O(1)

**Описание:**  
На каждом шаге берётся элемент из неотсортированной части и вставляется в нужное место в отсортированной.

**Пример:**
```python
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print(arr)  # [5, 6, 11, 12, 13]
```

---

### 1.4 Сортировка слиянием (Merge Sort)

**Сложность:**  
- Временная: O(n log n)  
- Пространственная: O(n)

**Описание:**  
Массив рекурсивно делится пополам, сортируются обе половины и затем сливаются в единый отсортированный массив.

**Пример:**
```python
arr = [38, 27, 43, 3, 9, 82, 10]
merge_sort(arr)
print(arr)  # [3, 9, 10, 27, 38, 43, 82]
```

---

### 1.5 Сортировка Шелла (Shell Sort)

**Сложность:**  
- Временная: O(n log² n)  
- Пространственная: O(1)

**Описание:**  
Обобщение сортировки вставками. Элементы сравниваются и переставляются на определённом интервале (gap), который постепенно уменьшается.

**Пример:**
```python
arr = [12, 34, 54, 2, 3]
shell_sort(arr)
print(arr)  # [2, 3, 12, 34, 54]
```

---

### 1.6 Быстрая сортировка (Quick Sort)

**Сложность:**  
- Временная: O(n log n) в среднем, O(n²) в худшем  
- Пространственная: O(log n)

**Описание:**  
Выбирается опорный элемент (pivot), после чего элементы разделяются на меньшие и большие.  
Алгоритм рекурсивно применяется к подмассивам.

**Пример:**
```python
arr = [10, 7, 8, 9, 1, 5]
quick_sort(arr)
print(arr)  # [1, 5, 7, 8, 9, 10]
```

---

### 1.7 Пирамидальная сортировка (Heap Sort)

**Сложность:**  
- Временная: O(n log n)  
- Пространственная: O(1)

**Описание:**  
Массив преобразуется в двоичную кучу (heap). Затем из неё извлекаются элементы по убыванию и формируется отсортированный массив.

**Пример:**
```python
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print(arr)  # [5, 6, 7, 11, 12, 13]
```

---

## 2. Алгоритмы поиска

### 2.1 Линейный поиск (Linear Search)

**Сложность:**  
- Временная: O(n)  
- Пространственная: O(1)

**Описание:**  
Последовательно сравнивает элементы массива с искомым значением.

**Пример:**
```python
arr = [10, 20, 30, 40]
print(linear_search(arr, 30))  # 2
```

---

### 2.2 Бинарный поиск (Binary Search)

**Сложность:**  
- Временная: O(log n)  
- Пространственная: O(1)

**Описание:**  
Применяется к отсортированному массиву. Делит диапазон пополам и сравнивает средний элемент с искомым.

**Пример:**
```python
arr = [10, 20, 30, 40, 50]
print(binary_search(arr, 30))  # 2
```

---

### 2.3 Интерполирующий поиск (Interpolation Search)

**Сложность:**  
- Временная: O(log log n) в среднем, O(n) в худшем  
- Пространственная: O(1)

**Описание:**  
Использует линейную интерполяцию для вычисления вероятной позиции элемента.  
Лучше работает при равномерно распределённых данных.

**Пример:**
```python
arr = [10, 20, 30, 40, 50]
print(interpolation_search(arr, 40))  # 3
```

---

### 2.4 Поиск по Фибоначчи (Fibonacci Search)

**Сложность:**  
- Временная: O(log n)  
- Пространственная: O(1)

**Описание:**  
Применяет числа Фибоначчи для разделения массива на интервалы поиска.  
Работает аналогично бинарному поиску, но использует золотое сечение.

**Пример:**
```python
arr = [10, 20, 30, 40, 50]
print(fibonacci_search(arr, 20))  # 1
```

---

## 3. Тестирование алгоритмов

Для тестирования всех алгоритмов сортировки и поиска в программе предусмотрены функции:

```python
test_sorting_algorithms()
test_search_algorithms()
```

**Пример вывода:**

```
======================================================================
ТЕСТИРОВАНИЕ АЛГОРИТМОВ СОРТИРОВКИ
======================================================================

Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Сортировка выбором: [11, 12, 22, 25, 34, 64, 90]
Сортировка пузырьком: [11, 12, 22, 25, 34, 64, 90]
...
Пирамидальная сортировка: [11, 12, 22, 25, 34, 64, 90]

======================================================================
ТЕСТИРОВАНИЕ АЛГОРИТМОВ ПОИСКА
======================================================================

Массив (отсортированный): [11, 12, 22, 25, 34, 64, 90]
Искомый элемент: 22
Бинарный поиск: индекс = 2
Интерполирующий поиск: индекс = 2
Поиск Фибоначчи: индекс = 2

Поиск отсутствующего элемента: 100
Бинарный поиск: -1
Интерполирующий поиск: -1
Поиск Фибоначчи: -1
```

---

## 4. Заключение

В работе были реализованы и протестированы классические алгоритмы сортировки и поиска.  
Результаты подтвердили ожидаемую асимптотическую сложность и корректность выполнения.  
Каждый алгоритм демонстрирует различные подходы к решению задач обработки данных и может быть выбран в зависимости от структуры и размера входных данных.
