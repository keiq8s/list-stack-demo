# Sort and Search algorithms

| Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Стабильность |
|----------|---------------|----------------|---------------|--------|--------------|
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | Нет |
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Да |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | Да |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | Да |
| Shell Sort | O(n log n) | O(n^1.5) | O(n²) | O(1) | Нет |
| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | Нет |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | Нет |


| Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Требует сортировки |
|----------|---------------|----------------|---------------|--------|--------------------|
| Linear Search | O(1) | O(n) | O(n) | O(1) | Нет |
| Binary Search | O(1) | O(log n) | O(log n) | O(1) | Да |
| Interpolation Search | O(1) | O(log log n) | O(n) | O(1) | Да (равномерное) |
| Fibonacci Search | O(1) | O(log n) | O(log n) | O(1) | Да |

---

## КОГДА ИСПОЛЬЗОВАТЬ КАКОЙ АЛГОРИТМ

### Сортировка:

**Для малых массивов (n < 50):**
- **Insertion Sort** — простая реализация, эффективна на малых данных

**Для средних и больших массивов:**
- **Quick Sort** — в среднем самая быстрая
- **Merge Sort** — гарантированная производительность O(n log n), стабильная
- **Heap Sort** — гарантированная производительность O(n log n) с минимальной памятью

**Специальные случаи:**
- **Почти отсортированные данные:** Insertion Sort O(n)
- **Нужна стабильность:** Merge Sort или Bubble Sort
- **Ограниченная память:** Heap Sort или Quick Sort

### Поиск:

**Несортированные данные:**
- **Linear Search** — единственный вариант

**Отсортированные данные:**
- **Binary Search** — универсальный выбор
- **Interpolation Search** — если данные равномерно распределены
- **Fibonacci Search** — альтернатива Binary Search с меньшим количеством операций деления

---

## ИТОГОВЫЕ ВЫВОДЫ

1. **O(n²) алгоритмы** (Selection, Bubble, Insertion) просты, но медленны на больших данных
2. **O(n log n) алгоритмы** (Merge, Quick, Heap) — стандарт для общих случаев
3. **Merge Sort** — лучший выбор, когда важна предсказуемость и стабильность
4. **Quick Sort** — самый быстрый в среднем, но требует осторожности с выбором pivot
5. **Binary Search** — золотой стандарт для поиска в отсортированных данных
6. **Выбор алгоритма** зависит от размера данных, требований к памяти и характеристик входных данных
