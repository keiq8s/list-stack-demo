"""
Практическая работа: Алгоритмы сортировки и поиска
Реализация на Python с построчными объяснениями и примерами выполнения
"""

import time

# ============================================================================
# АЛГОРИТМЫ СОРТИРОВКИ С ПРИМЕРАМИ ВЫПОЛНЕНИЯ
# ============================================================================

def selection_sort(arr):
    """
    Сортировка выбором (Selection Sort)
    Временная сложность: O(n²)
    Пространственная сложность: O(1)
    
    ПРИНЦИП РАБОТЫ:
    На каждой итерации находим минимальный элемент в неотсортированной части
    и меняем его местами с первым элементом неотсортированной части.
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Входной массив: [64, 25, 12, 22, 11]
    
    Проход 1: Ищем минимум в [64, 25, 12, 22, 11] → 11
              Меняем 64 ↔ 11: [11, 25, 12, 22, 64]
    
    Проход 2: Ищем минимум в [25, 12, 22, 64] → 12
              Меняем 25 ↔ 12: [11, 12, 25, 22, 64]
    
    Проход 3: Ищем минимум в [25, 22, 64] → 22
              Меняем 25 ↔ 22: [11, 12, 22, 25, 64]
    
    Проход 4: Ищем минимум в [25, 64] → 25
              25 уже на месте: [11, 12, 22, 25, 64]
    
    Результат: [11, 12, 22, 25, 64]
    """
    comparisons = 0
    swaps = 0
    
    # Внешний цикл: проходим по каждой позиции массива
    for i in range(len(arr)):
        # Предполагаем, что текущий элемент arr[i] - минимальный
        min_index = i
        
        # Внутренний цикл: ищем минимальный элемент в неотсортированной части
        # начиная с i+1 до конца массива
        for j in range(i + 1, len(arr)):
            comparisons += 1
            # Если нашли элемент меньше текущего минимального
            if arr[j] < arr[min_index]:
                # Обновляем индекс минимального элемента
                min_index = j
        
        # Если нашли элемент меньше arr[i]
        if min_index != i:
            # Меняем местами arr[i] и arr[min_index]
            # Используем множественное присваивание Python (tuple unpacking)
            arr[i], arr[min_index] = arr[min_index], arr[i]
            swaps += 1
    
    return arr, comparisons, swaps


def bubble_sort(arr):
    """
    Сортировка пузырьком (Bubble Sort)
    Временная сложность: O(n²) в худшем случае, O(n) в лучшем
    Пространственная сложность: O(1)
    
    ПРИНЦИП РАБОТЫ:
    Сравниваем соседние элементы и меняем их местами, если они в неправильном порядке.
    За каждый проход самый большой элемент "всплывает" в конец массива.
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Входной массив: [64, 34, 25, 12, 22]
    
    Проход 1:
      [64, 34, 25, 12, 22] → 64 > 34? Да → [34, 64, 25, 12, 22]
      [34, 64, 25, 12, 22] → 64 > 25? Да → [34, 25, 64, 12, 22]
      [34, 25, 64, 12, 22] → 64 > 12? Да → [34, 25, 12, 64, 22]
      [34, 25, 12, 64, 22] → 64 > 22? Да → [34, 25, 12, 22, 64]
      Самый большой элемент (64) на месте!
    
    Проход 2:
      [34, 25, 12, 22, 64] → 34 > 25? Да → [25, 34, 12, 22, 64]
      [25, 34, 12, 22, 64] → 34 > 12? Да → [25, 12, 34, 22, 64]
      [25, 12, 34, 22, 64] → 34 > 22? Да → [25, 12, 22, 34, 64]
      Второй по величине (34) на месте!
    
    Проход 3:
      [25, 12, 22, 34, 64] → 25 > 12? Да → [12, 25, 22, 34, 64]
      [12, 25, 22, 34, 64] → 25 > 22? Да → [12, 22, 25, 34, 64]
    
    Проход 4:
      [12, 22, 25, 34, 64] → 12 > 22? Нет → без изменений
      Не было обменов → массив отсортирован!
    
    Результат: [12, 22, 25, 34, 64]
    """
    n = len(arr)
    comparisons = 0
    swaps = 0
    
    # Внешний цикл: количество проходов по массиву (максимум n-1)
    for i in range(n - 1):
        # Флаг для оптимизации: отслеживаем, были ли обмены
        swapped = False
        
        # Внутренний цикл: сравниваем соседние элементы
        # Последние i элементов уже на своих местах, поэтому идем до n-i-1
        for j in range(n - i - 1):
            comparisons += 1
            # Если текущий элемент больше следующего
            if arr[j] > arr[j + 1]:
                # Меняем их местами (tuple unpacking в Python)
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swaps += 1
                # Отмечаем, что был обмен
                swapped = True
        
        # Если за весь проход не было ни одного обмена
        # значит массив уже отсортирован, выходим досрочно
        if not swapped:
            break
    
    return arr, comparisons, swaps


def insertion_sort(arr):
    """
    Сортировка вставками (Insertion Sort)
    Временная сложность: O(n²) в худшем случае, O(n) в лучшем
    Пространственная сложность: O(1)
    
    ПРИНЦИП РАБОТЫ:
    Делим массив на отсортированную и неотсортированную части.
    Берем элемент из неотсортированной части и вставляем на правильное место
    в отсортированную часть, сдвигая большие элементы вправо.
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Входной массив: [64, 25, 12, 22, 11]
    
    Итерация 1: key = 25, отсортированная часть [64]
      64 > 25? Да → сдвигаем 64 вправо: [64, 64, 12, 22, 11]
      Вставляем 25: [25, 64, 12, 22, 11]
    
    Итерация 2: key = 12, отсортированная часть [25, 64]
      64 > 12? Да → сдвигаем: [25, 64, 64, 22, 11]
      25 > 12? Да → сдвигаем: [25, 25, 64, 22, 11]
      Вставляем 12: [12, 25, 64, 22, 11]
    
    Итерация 3: key = 22, отсортированная часть [12, 25, 64]
      64 > 22? Да → сдвигаем: [12, 25, 64, 64, 11]
      25 > 22? Да → сдвигаем: [12, 25, 25, 64, 11]
      12 > 22? Нет → стоп
      Вставляем 22: [12, 22, 25, 64, 11]
    
    Итерация 4: key = 11, отсортированная часть [12, 22, 25, 64]
      64 > 11? Да → сдвигаем все вправо
      Вставляем 11: [11, 12, 22, 25, 64]
    
    Результат: [11, 12, 22, 25, 64]
    """
    comparisons = 0
    shifts = 0
    
    # Начинаем со второго элемента (индекс 1)
    # Первый элемент считается уже отсортированным
    for i in range(1, len(arr)):
        # key - элемент, который нужно вставить в отсортированную часть
        key = arr[i]
        
        # j - индекс для перемещения по отсортированной части справа налево
        j = i - 1
        
        # Сдвигаем элементы отсортированной части, которые больше key
        # на одну позицию вправо
        # Условие: j >= 0 (не вышли за границу) И arr[j] > key (элемент больше)
        while j >= 0 and arr[j] > key:
            comparisons += 1
            # Сдвигаем arr[j] на одну позицию вправо
            arr[j + 1] = arr[j]
            shifts += 1
            # Переходим к предыдущему элементу
            j -= 1
        
        # Учитываем последнее сравнение, если не вышли за границу
        if j >= 0:
            comparisons += 1
        
        # Вставляем key на найденное место
        # j+1 - правильная позиция для key
        arr[j + 1] = key
    
    return arr, comparisons, shifts


def merge_sort(arr):
    """
    Сортировка слиянием (Merge Sort)
    Временная сложность: O(n log n)
    Пространственная сложность: O(n)
    
    ПРИНЦИП РАБОТЫ (Разделяй и властвуй):
    1. РАЗДЕЛЯЙ: рекурсивно делим массив пополам до элементов
    2. ВЛАСТВУЙ: сортируем подмассивы (базовый случай - массив из 1 элемента)
    3. ОБЪЕДИНЯЙ: сливаем два отсортированных массива в один
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Входной массив: [38, 27, 43, 3, 9, 82, 10]
    
    РАЗДЕЛЕНИЕ (сверху вниз):
                    [38, 27, 43, 3, 9, 82, 10]
                    /                        \
          [38, 27, 43, 3]                [9, 82, 10]
          /            \                  /         \
      [38, 27]      [43, 3]          [9, 82]      [10]
      /     \        /    \          /     \
    [38]   [27]   [43]   [3]      [9]    [82]
    
    СЛИЯНИЕ (снизу вверх):
    Уровень 1: [38] + [27] = [27, 38]
               [43] + [3]  = [3, 43]
               [9]  + [82] = [9, 82]
    
    Уровень 2: [27, 38] + [3, 43] = [3, 27, 38, 43]
               [9, 82]  + [10]    = [9, 10, 82]
    
    Уровень 3: [3, 27, 38, 43] + [9, 10, 82] = [3, 9, 10, 27, 38, 43, 82]
    
    ДЕТАЛЬНОЕ СЛИЯНИЕ [27, 38] + [3, 43]:
    left = [27, 38], right = [3, 43], result = []
    
    Шаг 1: 27 vs 3  → 3 меньше  → result = [3]
    Шаг 2: 27 vs 43 → 27 меньше → result = [3, 27]
    Шаг 3: 38 vs 43 → 38 меньше → result = [3, 27, 38]
    Шаг 4: right закончился      → result = [3, 27, 38, 43]
    
    Результат: [3, 9, 10, 27, 38, 43, 82]
    """
    stats = {'comparisons': 0, 'merges': 0}
    
    def merge_sort_helper(arr):
        # Базовый случай: массив из 0 или 1 элемента уже отсортирован
        if len(arr) <= 1:
            return arr
        
        # Находим середину массива (целочисленное деление)
        mid = len(arr) // 2
        
        # Делим массив на две части используя срезы (slicing)
        # left: элементы от начала до mid (не включая mid)
        left = arr[:mid]
        # right: элементы от mid до конца
        right = arr[mid:]
        
        # Рекурсивно сортируем левую половину
        left = merge_sort_helper(left)
        # Рекурсивно сортируем правую половину
        right = merge_sort_helper(right)
        
        # Сливаем две отсортированные половины
        return merge(left, right, stats)
    
    sorted_arr = merge_sort_helper(arr)
    return sorted_arr, stats['comparisons'], stats['merges']


def merge(left, right, stats):
    """
    Вспомогательная функция для слияния двух отсортированных массивов
    
    ПОСТРОЧНОЕ ОБЪЯСНЕНИЕ:
    left = [3, 5], right = [2, 4] → result должен быть [2, 3, 4, 5]
    """
    # Результирующий массив
    result = []
    # Индексы для left и right массивов
    i = j = 0
    
    # Пока есть элементы в обоих массивах
    while i < len(left) and j < len(right):
        stats['comparisons'] += 1
        # Сравниваем текущие элементы из left и right
        if left[i] < right[j]:
            # Если элемент из left меньше, добавляем его в result
            result.append(left[i])
            # Переходим к следующему элементу в left
            i += 1
        else:
            # Иначе добавляем элемент из right
            result.append(right[j])
            # Переходим к следующему элементу в right
            j += 1
    
    # Добавляем оставшиеся элементы из left (если есть)
    # extend() добавляет все элементы среза left[i:] в result
    result.extend(left[i:])
    
    # Добавляем оставшиеся элементы из right (если есть)
    result.extend(right[j:])
    
    # Увеличиваем счетчик слияний
    stats['merges'] += 1
    
    return result


def quick_sort(arr):
    """
    Быстрая сортировка (Quick Sort)
    Временная сложность: O(n log n) в среднем, O(n²) в худшем
    Пространственная сложность: O(log n) из-за рекурсии
    
    ПРИНЦИП РАБОТЫ:
    1. Выбираем опорный элемент (pivot)
    2. Разделяем массив на три части: < pivot, = pivot, > pivot
    3. Рекурсивно сортируем левую и правую части
    4. Объединяем результат
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Входной массив: [10, 7, 8, 9, 1, 5]
    
    Шаг 1: pivot = 8 (средний элемент)
      left   = [7, 1, 5]  (элементы < 8)
      middle = [8]        (элементы = 8)
      right  = [10, 9]    (элементы > 8)
    
    Шаг 2: Сортируем left = [7, 1, 5]
      pivot = 1
      left   = []
      middle = [1]
      right  = [7, 5]
      
      Сортируем right = [7, 5]
        pivot = 5
        left   = []
        middle = [5]
        right  = [7]
        Результат: [] + [5] + [7] = [5, 7]
      
      Результат left: [] + [1] + [5, 7] = [1, 5, 7]
    
    Шаг 3: Сортируем right = [10, 9]
      pivot = 9
      left   = []
      middle = [9]
      right  = [10]
      Результат: [] + [9] + [10] = [9, 10]
    
    Финал: [1, 5, 7] + [8] + [9, 10] = [1, 5, 7, 8, 9, 10]
    
    Результат: [1, 5, 7, 8, 9, 10]
    """
    stats = {'comparisons': 0, 'partitions': 0}
    
    def quick_sort_helper(arr):
        # Базовый случай: массив из 0 или 1 элемента уже отсортирован
        if len(arr) <= 1:
            return arr
        
        # Выбираем опорный элемент (pivot) - средний элемент массива
        # Это хороший выбор для частично отсортированных данных
        pivot = arr[len(arr) // 2]
        
        # Увеличиваем счетчик разделений
        stats['partitions'] += 1
        
        # Создаем три подмассива используя list comprehension
        # left: все элементы меньше pivot
        left = []
        # middle: все элементы равные pivot
        middle = []
        # right: все элементы больше pivot
        right = []
        
        # Проходим по всем элементам массива
        for x in arr:
            stats['comparisons'] += 1
            # Сравниваем элемент с pivot и добавляем в соответствующий список
            if x < pivot:
                left.append(x)
            elif x == pivot:
                middle.append(x)
            else:
                right.append(x)
        
        # Рекурсивно сортируем левую и правую части
        # Объединяем результат: sorted(left) + middle + sorted(right)
        # Элементы middle уже на правильных местах
        return quick_sort_helper(left) + middle + quick_sort_helper(right)
    
    sorted_arr = quick_sort_helper(arr)
    return sorted_arr, stats['comparisons'], stats['partitions']


# ============================================================================
# АЛГОРИТМЫ ПОИСКА С ПРИМЕРАМИ ВЫПОЛНЕНИЯ
# ============================================================================

def linear_search(arr, target):
    """
    Последовательный (линейный) поиск
    Временная сложность: O(n)
    Пространственная сложность: O(1)
    
    ПРИНЦИП РАБОТЫ:
    Последовательно проверяем каждый элемент массива до нахождения искомого.
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Массив: [64, 34, 25, 12, 22], target = 25
    
    Итерация 0: arr[0] = 64, 64 == 25? Нет, продолжаем
    Итерация 1: arr[1] = 34, 34 == 25? Нет, продолжаем
    Итерация 2: arr[2] = 25, 25 == 25? Да! Возвращаем индекс 2
    
    Результат: индекс = 2, сравнений = 3
    
    ПРИМЕР С ОТСУТСТВУЮЩИМ ЭЛЕМЕНТОМ:
    Массив: [64, 34, 25, 12, 22], target = 100
    
    Проверяем все элементы: 64, 34, 25, 12, 22
    Элемент не найден
    
    Результат: индекс = -1, сравнений = 5
    """
    comparisons = 0
    
    # Проходим по каждому элементу массива используя range
    # range(len(arr)) генерирует индексы от 0 до len(arr)-1
    for i in range(len(arr)):
        # Увеличиваем счетчик сравнений
        comparisons += 1
        # Сравниваем текущий элемент с искомым значением
        if arr[i] == target:
            # Если нашли - возвращаем индекс и количество сравнений
            return i, comparisons
    
    # Если прошли весь массив и не нашли элемент
    # возвращаем -1 как индикатор "не найдено"
    return -1, comparisons


def binary_search(arr, target):
    """
    Бинарный (двоичный) поиск
    Временная сложность: O(log n)
    Пространственная сложность: O(1)
    ТРЕБУЕТ: отсортированный массив
    
    ПРИНЦИП РАБОТЫ:
    На каждой итерации сравниваем target с элементом в середине массива.
    Отбрасываем половину массива и повторяем для оставшейся части.
    
    ПРИМЕР ВЫПОЛНЕНИЯ:
    Массив: [11, 12, 22, 25, 34, 64, 90], target = 25
    
    Итерация 1:
      left = 0, right = 6, mid = 3
      arr[3] = 25
      25 == 25? Да! Найдено на индексе 3
    
    Результат: индекс = 3, сравнений = 1
    
    ДЕТАЛЬНЫЙ ПРИМЕР:
    Массив: [11, 12, 22, 25, 34, 64, 90], target = 34
    
    Итерация 1:
      left = 0, right = 6
      mid = 0 + (6 - 0) // 2 = 3
      arr[3] = 25, 25 == 34? Нет
      25 < 34 → ищем в правой половине
      left = 4
    
    Итерация 2:
      left = 4, right = 6
      mid = 4 + (6 - 4) // 2 = 5
      arr[5] = 64, 64 == 34? Нет
      64 > 34 → ищем в левой половине
      right = 4
    
    Итерация 3:
      left = 4, right = 4
      mid = 4 + (4 - 4) // 2 = 4
      arr[4] = 34, 34 == 34? Да!
    
    Результат: индекс = 4, сравнений = 3
    """
    # Левая граница поиска (начало массива)
    left = 0
    # Правая граница поиска (конец массива)
    right = len(arr) - 1
    # Счетчик сравнений
    comparisons = 0
    
    # Продолжаем поиск пока границы не пересеклись
    while left <= right:
        # Вычисляем средний индекс
        # Используем left + (right - left) // 2 вместо (left + right) // 2
        # чтобы избежать переполнения при больших значениях
        mid = left + (right - left) // 2
        
        # Увеличиваем счетчик сравнений
        comparisons += 1
        
        # Если средний элемент равен искомому
        if arr[mid] == target:
            # Возвращаем индекс и количество сравнений
            return mid, comparisons
        
        # Если средний элемент больше искомого
        elif arr[mid] > target:
            # Искомый элемент в левой половине
            # Сдвигаем правую границу влево
            right = mid - 1
        
        # Если средний элемент меньше искомого
        else:
            # Искомый элемент в правой половине
            # Сдвигаем левую границу вправо
            left = mid + 1
    
    # Элемент не найден (границы пересеклись)
    return -1, comparisons


# ============================================================================
# ТЕСТИРОВАНИЕ С ПРИМЕРАМИ РАБОТЫ
# ============================================================================

def print_header(title):
    """Печать заголовка"""
    print("\n" + "=" * 80)
    print(f" {title}")
    print("=" * 80)


def print_step_by_step_example():
    """Демонстрация пошагового выполнения"""
    print_header("ПОШАГОВЫЕ ПРИМЕРЫ ВЫПОЛНЕНИЯ АЛГОРИТМОВ")
    
    print("\n1. SELECTION SORT - Пошаговое выполнение:")
    print("-" * 80)
    arr = [64, 25, 12, 22, 11]
    print(f"Исходный массив: {arr}")
    
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        print(f"\nПроход {i+1}:")
        print(f"  Неотсортированная часть: {arr[i:]}")
        print(f"  Минимальный элемент: {arr[min_idx]} на позиции {min_idx}")
        
        if min_idx != i:
            arr[i], arr[min_idx] = arr[min_idx], arr[i]
            print(f"  Обмен: позиция {i} ↔ позиция {min_idx}")
        else:
            print(f"  Элемент {arr[i]} уже на месте")
        
        print(f"  Результат: {arr}")
        print(f"  Отсортированная часть: {arr[:i+1]}")
    
    print("\n" + "─" * 80)
    print("\n2. BINARY SEARCH - Пошаговое выполнение:")
    print("-" * 80)
    arr = [11, 12, 22, 25, 34, 64, 90]
    target = 34
    print(f"Массив: {arr}")
    print(f"Ищем: {target}")
    
    left, right = 0, len(arr) - 1
    iteration = 1
    
    while left <= right:
        mid = left + (right - left) // 2
        print(f"\nИтерация {iteration}:")
        print(f"  Границы: left={left}, right={right}, mid={mid}")
        print(f"  Подмассив: {arr[left:right+1]}")
        print(f"  Средний элемент: arr[{mid}] = {arr[mid]}")
        
        if arr[mid] == target:
            print(f"  {arr[mid]} == {target}? ✓ Да! Найдено на индексе {mid}")
            break
        elif arr[mid] > target:
            print(f"  {arr[mid]} > {target}? ✓ Ищем в левой половине")
            right = mid - 1
        else:
            print(f"  {arr[mid]} < {target}? ✓ Ищем в правой половине")
            left = mid + 1
        
        iteration += 1


def test_sorting_algorithm(name, sort_func, arr):
    """Тестирование алгоритма сортировки"""
    test_arr = arr.copy()
    
    print(f"\n{name}")
    print("-" * 80)
    print(f"Исходный массив:      {test_arr}")
    
    start_time = time.time()
    result = sort_func(test_arr)
    en
