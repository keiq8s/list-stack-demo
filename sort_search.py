"""
Практическая работа: Алгоритмы сортировки и поиска
Все алгоритмы реализованы на Python с подробными комментариями
"""

# ============================================================================
# АЛГОРИТМЫ СОРТИРОВКИ
# ============================================================================

def selection_sort(arr):
    """
    Сортировка выбором (Selection Sort)
    Временная сложность: O(n²)
    Пространственная сложность: O(1)
    """
    # Проходим по всем элементам массива
    for i in range(len(arr)):
        # Предполагаем, что текущий элемент минимальный
        min_index = i
        
        # Ищем минимальный элемент в оставшейся части массива
        for j in range(i + 1, len(arr)):
            # Если найден элемент меньше текущего минимального
            if arr[j] < arr[min_index]:
                # Обновляем индекс минимального элемента
                min_index = j
        
        # Меняем местами найденный минимальный элемент с первым элементом
        # в неотсортированной части массива
        arr[i], arr[min_index] = arr[min_index], arr[i]
    
    return arr


def bubble_sort(arr):
    """
    Сортировка пузырьком (Bubble Sort)
    Временная сложность: O(n²)
    Пространственная сложность: O(1)
    """
    n = len(arr)
    
    # Внешний цикл - количество проходов по массиву
    for i in range(n - 1):
        # Флаг для оптимизации: если за проход не было обменов, массив отсортирован
        swapped = False
        
        # Внутренний цикл - сравнение соседних элементов
        # Последние i элементов уже на своих местах
        for j in range(n - i - 1):
            # Если текущий элемент больше следующего
            if arr[j] > arr[j + 1]:
                # Меняем их местами
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # Если не было обменов, массив уже отсортирован
        if not swapped:
            break
    
    return arr


def insertion_sort(arr):
    """
    Сортировка вставками (Insertion Sort)
    Временная сложность: O(n²) в худшем случае, O(n) в лучшем
    Пространственная сложность: O(1)
    """
    # Начинаем со второго элемента (первый считается отсортированным)
    for i in range(1, len(arr)):
        # Запоминаем текущий элемент, который нужно вставить
        key = arr[i]
        
        # Индекс предыдущего элемента
        j = i - 1
        
        # Сдвигаем элементы отсортированной части, которые больше key,
        # на одну позицию вправо
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # Вставляем key на правильное место
        arr[j + 1] = key
    
    return arr


def merge_sort(arr):
    """
    Сортировка слиянием (Merge Sort)
    Временная сложность: O(n log n)
    Пространственная сложность: O(n)
    """
    # Базовый случай: массив из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Находим середину массива
    mid = len(arr) // 2
    
    # Делим массив на две части
    left = arr[:mid]
    right = arr[mid:]
    
    # Рекурсивно сортируем обе части
    left = merge_sort(left)
    right = merge_sort(right)
    
    # Сливаем отсортированные части
    return merge(left, right)


def merge(left, right):
    """
    Вспомогательная функция для слияния двух отсортированных массивов
    """
    result = []
    i = j = 0
    
    # Сравниваем элементы из обоих массивов и добавляем меньший в результат
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Добавляем оставшиеся элементы из левого массива
    result.extend(left[i:])
    
    # Добавляем оставшиеся элементы из правого массива
    result.extend(right[j:])
    
    return result


def shell_sort(arr):
    """
    Сортировка Шелла (Shell Sort)
    Временная сложность: зависит от последовательности gap, обычно O(n log² n)
    Пространственная сложность: O(1)
    """
    n = len(arr)
    
    # Начинаем с большого промежутка и уменьшаем его
    gap = n // 2
    
    # Продолжаем, пока gap не станет равным 0
    while gap > 0:
        # Проходим по элементам с текущим промежутком
        for i in range(gap, n):
            # Сохраняем текущий элемент
            temp = arr[i]
            j = i
            
            # Сдвигаем элементы, которые больше temp, на gap позиций вправо
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            
            # Вставляем temp на правильное место
            arr[j] = temp
        
        # Уменьшаем gap
        gap //= 2
    
    return arr


def quick_sort(arr):
    """
    Быстрая сортировка (Quick Sort)
    Временная сложность: O(n log n) в среднем, O(n²) в худшем
    Пространственная сложность: O(log n) из-за рекурсии
    """
    # Базовый случай: массив из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Выбираем опорный элемент (pivot) - средний элемент массива
    pivot = arr[len(arr) // 2]
    
    # Разделяем массив на три части:
    # left - элементы меньше pivot
    left = [x for x in arr if x < pivot]
    
    # middle - элементы равные pivot
    middle = [x for x in arr if x == pivot]
    
    # right - элементы больше pivot
    right = [x for x in arr if x > pivot]
    
    # Рекурсивно сортируем левую и правую части и объединяем результат
    return quick_sort(left) + middle + quick_sort(right)


def heap_sort(arr):
    """
    Пирамидальная сортировка (Heap Sort)
    Временная сложность: O(n log n)
    Пространственная сложность: O(1)
    """
    n = len(arr)
    
    # Построение max-heap
    # Начинаем с последнего родительского узла и двигаемся к корню
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Извлекаем элементы из heap один за другим
    for i in range(n - 1, 0, -1):
        # Перемещаем текущий корень (максимальный элемент) в конец
        arr[i], arr[0] = arr[0], arr[i]
        
        # Вызываем heapify на уменьшенной куче
        heapify(arr, i, 0)
    
    return arr


def heapify(arr, n, i):
    """
    Вспомогательная функция для поддержания свойства max-heap
    n - размер кучи
    i - индекс корня поддерева
    """
    # Инициализируем наибольший элемент как корень
    largest = i
    
    # Вычисляем индексы левого и правого дочерних узлов
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Если левый дочерний элемент существует и больше корня
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # Если правый дочерний элемент существует и больше текущего наибольшего
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # Если наибольший элемент не корень
    if largest != i:
        # Меняем местами
        arr[i], arr[largest] = arr[largest], arr[i]
        
        # Рекурсивно применяем heapify к затронутому поддереву
        heapify(arr, n, largest)


# ============================================================================
# АЛГОРИТМЫ ПОИСКА
# ============================================================================

def linear_search(arr, target):
    """
    Последовательный (линейный) поиск
    Временная сложность: O(n)
    Пространственная сложность: O(1)
    """
    # Проходим по каждому элементу массива
    for i in range(len(arr)):
        # Если нашли искомый элемент
        if arr[i] == target:
            # Возвращаем его индекс
            return i
    
    # Если элемент не найден, возвращаем -1
    return -1


def binary_search(arr, target):
    """
    Бинарный (двоичный) поиск
    Требует отсортированный массив
    Временная сложность: O(log n)
    Пространственная сложность: O(1)
    """
    # Устанавливаем левую и правую границы поиска
    left = 0
    right = len(arr) - 1
    
    # Продолжаем поиск, пока границы не пересекутся
    while left <= right:
        # Находим средний индекс (избегаем переполнения)
        mid = left + (right - left) // 2
        
        # Если средний элемент равен искомому
        if arr[mid] == target:
            return mid
        
        # Если искомый элемент меньше среднего
        elif arr[mid] > target:
            # Ищем в левой половине
            right = mid - 1
        
        # Если искомый элемент больше среднего
        else:
            # Ищем в правой половине
            left = mid + 1
    
    # Элемент не найден
    return -1


def interpolation_search(arr, target):
    """
    Интерполирующий поиск
    Требует отсортированный массив с равномерным распределением
    Временная сложность: O(log log n) в среднем, O(n) в худшем
    Пространственная сложность: O(1)
    """
    # Устанавливаем границы поиска
    low = 0
    high = len(arr) - 1
    
    # Продолжаем поиск, пока элемент находится в диапазоне
    while low <= high and target >= arr[low] and target <= arr[high]:
        # Если массив сузился до одного элемента
        if low == high:
            if arr[low] == target:
                return low
            return -1
        
        # Вычисляем предполагаемую позицию с помощью интерполяции
        # Формула основана на линейной интерполяции
        pos = low + ((target - arr[low]) * (high - low) // (arr[high] - arr[low]))
        
        # Проверяем границы pos
        if pos < low or pos > high:
            return -1
        
        # Если элемент найден
        if arr[pos] == target:
            return pos
        
        # Если искомый элемент больше, ищем в правой части
        if arr[pos] < target:
            low = pos + 1
        
        # Если искомый элемент меньше, ищем в левой части
        else:
            high = pos - 1
    
    # Элемент не найден
    return -1


def fibonacci_search(arr, target):
    """
    Поиск по Фибоначчи
    Требует отсортированный массив
    Временная сложность: O(log n)
    Пространственная сложность: O(1)
    """
    n = len(arr)
    
    # Инициализируем числа Фибоначчи
    fib_m2 = 0  # (m-2)-е число Фибоначчи
    fib_m1 = 1  # (m-1)-е число Фибоначчи
    fib_m = fib_m2 + fib_m1  # m-е число Фибоначчи
    
    # Находим наименьшее число Фибоначчи >= n
    while fib_m < n:
        fib_m2 = fib_m1
        fib_m1 = fib_m
        fib_m = fib_m2 + fib_m1
    
    # Смещение для исключенного диапазона спереди
    offset = -1
    
    # Пока есть элементы для проверки
    while fib_m > 1:
        # Проверяем, является ли fib_m2 допустимым индексом
        i = min(offset + fib_m2, n - 1)
        
        # Если target больше значения на индексе i
        if arr[i] < target:
            # Переходим на два числа Фибоначчи вниз
            fib_m = fib_m1
            fib_m1 = fib_m2
            fib_m2 = fib_m - fib_m1
            offset = i
        
        # Если target меньше значения на индексе i
        elif arr[i] > target:
            # Переходим на одно число Фибоначчи вниз
            fib_m = fib_m2
            fib_m1 = fib_m1 - fib_m2
            fib_m2 = fib_m - fib_m1
        
        # Элемент найден
        else:
            return i
    
    # Проверяем последний элемент
    if fib_m1 and offset + 1 < n and arr[offset + 1] == target:
        return offset + 1
    
    # Элемент не найден
    return -1


# ============================================================================
# ТЕСТИРОВАНИЕ АЛГОРИТМОВ
# ============================================================================

def test_sorting_algorithms():
    """Тестирование всех алгоритмов сортировки"""
    print("=" * 70)
    print("ТЕСТИРОВАНИЕ АЛГОРИТМОВ СОРТИРОВКИ")
    print("=" * 70)
    
    test_array = [64, 34, 25, 12, 22, 11, 90]
    
    # Сортировка выбором
    arr = test_array.copy()
    print(f"\nИсходный массив: {arr}")
    selection_sort(arr)
    print(f"Сортировка выбором: {arr}")
    
    # Сортировка пузырьком
    arr = test_array.copy()
    bubble_sort(arr)
    print(f"Сортировка пузырьком: {arr}")
    
    # Сортировка вставками
    arr = test_array.copy()
    insertion_sort(arr)
    print(f"Сортировка вставками: {arr}")
    
    # Сортировка слиянием
    arr = test_array.copy()
    arr = merge_sort(arr)
    print(f"Сортировка слиянием: {arr}")
    
    # Сортировка Шелла
    arr = test_array.copy()
    shell_sort(arr)
    print(f"Сортировка Шелла: {arr}")
    
    # Быстрая сортировка
    arr = test_array.copy()
    arr = quick_sort(arr)
    print(f"Быстрая сортировка: {arr}")
    
    # Пирамидальная сортировка
    arr = test_array.copy()
    heap_sort(arr)
    print(f"Пирамидальная сортировка: {arr}")


def test_search_algorithms():
    """Тестирование всех алгоритмов поиска"""
    print("\n" + "=" * 70)
    print("ТЕСТИРОВАНИЕ АЛГОРИТМОВ ПОИСКА")
    print("=" * 70)
    
    # Массив для линейного поиска (несортированный)
    unsorted_array = [64, 34, 25, 12, 22, 11, 90]
    
    # Массив для других алгоритмов (отсортированный)
    sorted_array = [11, 12, 22, 25, 34, 64, 90]
    
    target = 22
    
    # Линейный поиск
    print(f"\nМассив (несортированный): {unsorted_array}")
    print(f"Искомый элемент: {target}")
    result = linear_search(unsorted_array, target)
    print(f"Линейный поиск: индекс = {result}")
    
    # Бинарный поиск
    print(f"\nМассив (отсортированный): {sorted_array}")
    print(f"Искомый элемент: {target}")
    result = binary_search(sorted_array, target)
    print(f"Бинарный поиск: индекс = {result}")
    
    # Интерполирующий поиск
    result = interpolation_search(sorted_array, target)
    print(f"Интерполирующий поиск: индекс = {result}")
    
    # Поиск Фибоначчи
    result = fibonacci_search(sorted_array, target)
    print(f"Поиск Фибоначчи: индекс = {result}")
    
    # Тест с отсутствующим элементом
    target = 100
    print(f"\nПоиск отсутствующего элемента: {target}")
    print(f"Линейный поиск: {linear_search(unsorted_array, target)}")
    print(f"Бинарный поиск: {binary_search(sorted_array, target)}")
    print(f"Интерполирующий поиск: {interpolation_search(sorted_array, target)}")
    print(f"Поиск Фибоначчи: {fibonacci_search(sorted_array, target)}")


# ============================================================================
# ГЛАВНАЯ ФУНКЦИЯ
# ============================================================================

if __name__ == "__main__":
    # Запускаем тестирование
    test_sorting_algorithms()
    test_search_algorithms()
    
    print("\n" + "=" * 70)
    print("ТЕСТИРОВАНИЕ ЗАВЕРШЕНО")
    print("=" * 70)
